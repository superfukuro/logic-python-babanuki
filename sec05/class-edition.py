# -*- coding: utf-8 -*-
"""class-edition.ipynb
Automatically generated by Colaboratory.
"""

import random


class Dealer():

    def __init__(self):
        self.initial_deck = self.create_initial_deck()

    def create_initial_deck(self) -> list:
        """
        Create a list object containing 53 cards. 
        The X card is a baba (joker).
        """
        initial_deck = []
        for n in range(1, 14):
            if n == 1:
                egara = 'A'
            elif n == 11:
                egara = 'J'
            elif n == 12:
                egara = 'Q'
            elif n == 13:
                egara = 'K'
            else:
                egara = str(n)
            initial_deck.append(egara)
        initial_deck = initial_deck * 4
        initial_deck.append('X')
        return initial_deck

    def initial_deal(self, *args: tuple) -> list:
        """
        Deal cards to players automatically.
        """
        players = list(args)
        random.shuffle(self.initial_deck)
        q, mod = divmod(len(self.initial_deck), len(players))
        for i in range(len(players)):
            slice_n = q
            if i < mod:
                slice_n = q + 1
            players[i].deck = self.initial_deck[:slice_n]
            del self.initial_deck[:slice_n]
        return players

    def initial_putdown(self, deck: list) -> list:
        """
        Play(put down) matching cards.
        """
        while len(set(deck)) != len(deck):
            popped_card = deck.pop(0)
            if popped_card in deck:
                deck.remove(popped_card)
            else:
                deck.append(popped_card)
        return deck

      
class Player():
    
    def __init__(self, name: str, is_auto: bool = True):
        """
        Create a player dict.
        """
        self.name = name
        self.deck = []
        self.is_win = False
        self.is_auto = is_auto

    def __repr__(self):
        return self.name + ' Object'


class Babanuki():

    def __init__(self, players: list):
        self.players = players

    def create_turn_index(self, passer_i: int, taker_i: int) -> tuple:
        """
        Create an index to determine if it is a passer or a taker.
        """
        passer_i = taker_i
        taker_i = taker_i + 1
        if passer_i >= len(self.players):
            passer_i = 0
            taker_i = 1
        elif taker_i >= len(self.players):
            taker_i = 0
        return passer_i, taker_i

    def select(self, passer: object, taker: object) -> str:
        """
        Select card.
        *(passer["deck"]) Return is not required for destructive methods(pop).
        """
        if taker.is_auto:
            select_index = random.randrange(len(passer.deck))
        else:
            while True:
                text = ''
                for n in range(len(passer.deck)):
                    text += f'[{n+1}] '
                select_index = input(f'Select card of {passer.name} from {text}: ')
                try:
                    select_index = int(select_index) - 1
                    if select_index < 0 or select_index >= len(passer.deck):
                        raise IndexError()
                except ValueError:
                    print('\t*please input intger!!!')
                except IndexError:
                    print('\t*please input right number!!!')
                else:
                    break
            print(f'\tYou choose {select_index+1}.')
        selected_card = passer.deck.pop(select_index)
        return selected_card

    def putdown_or_add(self, selected_card: str, taker: object):
        """
        Put down or add a card.
        *Return is not required for destructive methods.
        """
        try:
            taker.deck.remove(selected_card)
        except ValueError:
            taker.deck.append(selected_card)

    def run(self):
        """
        Start the game.
        """
        passer_i = -1
        taker_i = 0
        loop = 0
        rank = []

        print(f'GAME START')

        while True:
            loop += 1
            print(f'\n --- TURN {loop} --- ')

            passer_i, taker_i = self.create_turn_index(passer_i, taker_i)

            selected_card = self.select(self.players[passer_i], self.players[taker_i])

            self.putdown_or_add(selected_card, self.players[taker_i])

            print(f'\tCurrent card number: ', end='')
            for i in range(len(self.players)):
                print(f'{self.players[i].name}:{len(self.players[i].deck)} ', end='')
                if len(self.players[i].deck) == 0:
                    print('*WIN ', end='')
                    rank.append(self.players.pop(i))
                    break

            if len(self.players) < 2:
                break

        rank.append(self.players.pop())

        print('\n\nGAME END\n')
        for i in range(len(rank)):
            print(f'RANK {i+1}: {rank[i].name}')

