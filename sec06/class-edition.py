# -*- coding: utf-8 -*-
"""class-edition.ipynb
Automatically generated by Colaboratory.
"""

import random


class Dealer():

    def __init__(self, *args):
        self.initial_deck = self.create_initial_deck()
        self.players = self.initial_deal(*args)
        for i in range(len(self.players)):
            self.players[i].deck = self.initial_putdown(self.players[i].deck)

    def create_initial_deck(self) -> list:
        """
        Create a list object containing 53 cards. 
        The X card is a baba (joker).
        """
        initial_deck = []
        for n in range(1, 14):
            if n == 1:
                egara = 'A'
            elif n == 11:
                egara = 'J'
            elif n == 12:
                egara = 'Q'
            elif n == 13:
                egara = 'K'
            else:
                egara = str(n)
            initial_deck.append(egara)
        initial_deck = initial_deck * 4
        initial_deck.append('X')
        return initial_deck

    def initial_deal(self, *args: tuple) -> list:
        """
        Deal cards to players automatically.
        """
        players = list(args)
        random.shuffle(self.initial_deck)
        q, mod = divmod(len(self.initial_deck), len(players))
        for i in range(len(players)):
            slice_n = q
            if i < mod:
                slice_n = q + 1
            players[i].deck = self.initial_deck[:slice_n]
            del self.initial_deck[:slice_n]
        return players

    def initial_putdown(self, deck: list) -> list:
        """
        Play(put down) matching cards.
        """
        while len(set(deck)) != len(deck):
            popped_card = deck.pop(0)
            if popped_card in deck:
                deck.remove(popped_card)
            else:
                deck.append(popped_card)
        return deck


class Player():

    def __init__(self, name: str, is_auto: bool = True):
        """
        Create a player instance.
        """
        self.name = name
        self.deck = []
        self.card_exists = True
        self.is_auto = is_auto

    def __repr__(self):
        return self.name + ' Object'


class Babanuki():

    def __init__(self, players: list, passer_i: int = 0):
        self.players = players
        # これだと、誰から始まるのかが正確ではない
        # self.passer_i = passer_i - 1
        # 正しい値をセットしておき、create_turn_indexを使用する際の初回だけ -1 する
        self.passer_i = passer_i
        self.taker_i = self.passer_i + 1
        self.passer = self.players[self.passer_i]
        self.taker = self.players[self.taker_i]
        self.rank = []
        for player in self.players:
            self.check_is_zero(player)

    def create_turn_index(self) -> None:
        """
        Create an index to determine if it is a passer or a taker.
        """
        def decide_turn_index(
                turn_i: int, players: list, check_equal: int = None) -> int:
            """
            Decide a turn index.
            """
            while True:
                if turn_i >= len(players):
                    turn_i = 0
                    continue
                if not players[turn_i].card_exists:
                    turn_i += 1
                    continue
                if turn_i == check_equal:
                    turn_i += 1
                    continue
                break
            return turn_i

        self.passer_i = self.taker_i
        self.passer_i = decide_turn_index(self.passer_i, self.players)
        self.taker_i = self.passer_i + 1
        self.taker_i = decide_turn_index(
            self.taker_i, self.players, check_equal=self.passer_i)

    def select(self) -> str:
        """
        Select card.
        *(passer.deck) Return is not required for destructive methods(pop).
        """
        if self.taker.is_auto:
            select_index = random.randrange(len(self.passer.deck))
        else:
            while True:
                text = ''
                for n in range(len(self.passer.deck)):
                    text += f'[{n+1}] '
                select_index = input(
                    f'\n\n\tSelect card of {self.passer.name} from {text}: ')
                try:
                    select_index = int(select_index) - 1
                    if select_index < 0 or select_index >= len(self.passer.deck):
                        raise IndexError()
                except ValueError:
                    print('\t*please input intger!!!')
                except IndexError:
                    print('\t*please input right number!!!')
                else:
                    break
            print('\n\t', end='')
        selected_card = self.passer.deck.pop(select_index)
        return selected_card

    def putdown_or_add(self, selected_card: str) -> None:
        """
        Put down or add a card.
        *Return is not required for destructive methods.
        """
        try:
            self.taker.deck.remove(selected_card)
        except ValueError:
            self.taker.deck.append(selected_card)

    def check_is_zero(self, player: Player) -> None:
        """
        Check how many cards player have on hand.
        """
        if len(player.deck) == 0:
            player.card_exists = False
            self.rank.append(player.name)

    def run(self) -> None:
        """
        Start the game.
        """
        # create_turn_index で初期のpasserとtakerがずれるので、
        # -1しておく
        self.passer_i = self.passer_i - 1
        self.taker_i = self.taker_i - 1

        print('BABANUKI GAME START')
        loop = 0
        while len(self.players) - len(self.rank) > 1:
            loop += 1
            print(f'\n[TURN {loop}]', end='')

            self.create_turn_index()

            self.passer = self.players[self.passer_i]
            self.taker = self.players[self.taker_i]

            print(f'\t{self.passer.name} --> {self.taker.name}', end='')

            text = '\t\t'
            for player in self.players:
                text += f'{player.name}:{len(player.deck)} '
            print(text, end='')

            selected_card = self.select()
            self.check_is_zero(self.passer)

            self.putdown_or_add(selected_card)
            self.check_is_zero(self.taker)

            text = '==> '
            for player in self.players:
                text += f'{player.name}:{len(player.deck)} '
            print(text, end='')

            print(f'\tWINNERS: {",".join(self.rank)}', end='')

        player_name = [p.name for p in self.players if p.card_exists][0]
        self.rank.append(player_name)

        print('\n\nBABANUKI GAME END\n')
        for i, name in enumerate(self.rank):
            print(f'RANK {i+1}: {name}')
            
