# -*- coding: utf-8 -*-
"""function-edition.ipynb
Automatically generated by Colaboratory.
"""

import random


def create_initial_deck() -> list:
    """
    Create a list object containing 53 cards. 
    The X card is a baba (joker).
    """
    initial_deck = []
    for n in range(1, 14):
        if n == 1:
            egara = 'A'
        elif n == 11:
            egara = 'J'
        elif n == 12:
            egara = 'Q'
        elif n == 13:
            egara = 'K'
        else:
            egara = str(n)
        initial_deck.append(egara)
    initial_deck = initial_deck * 4
    initial_deck.append('X')
    return initial_deck


def create_player(name: str, is_auto: bool = True) -> dict:
    """
    Create a player dict.
    """
    return {
        'name': name,
        'deck': [],
        'card_exists': True,
        'is_auto': is_auto,
    }


def initial_deal(initial_deck: list, *args: tuple) -> list:
    """
    Deal cards to players automatically.
    """
    players = list(args)
    random.shuffle(initial_deck)
    q, mod = divmod(len(initial_deck), len(players))
    for i in range(len(players)):
        slice_n = q
        if i < mod:
            slice_n = q + 1
        players[i]["deck"] = initial_deck[:slice_n]
        del initial_deck[:slice_n]
    return players


def initial_putdown(deck: list) -> list:
    """
    Play(put down) matching cards.
    """
    while len(set(deck)) != len(deck):
        popped_card = deck.pop(0)
        if popped_card in deck:
            deck.remove(popped_card)
        else:
            deck.append(popped_card)
    return deck


def create_turn_index(passer_i: int, taker_i: int, players: list) -> tuple:
    """
    Create an index to determine if it is a passer or a taker.
    """
    def decide_turn_index(
            turn_i: int, players: list, check_equal: int = None) -> int:
        """
        Decide a turn index.
        """
        while True:
            if turn_i >= len(players):
                turn_i = 0
                continue
            if not players[turn_i]['card_exists']:
                turn_i += 1
                continue
            if turn_i == check_equal:
                turn_i += 1
                continue
            break
        return turn_i
    passer_i = taker_i
    passer_i = decide_turn_index(passer_i, players)
    taker_i = passer_i + 1
    taker_i = decide_turn_index(taker_i, players, check_equal=passer_i)
    return passer_i, taker_i


def select(passer: dict, taker: dict) -> str:
    """
    Select card.
    *(passer["deck"]) Return is not required for destructive methods(pop).
    """
    if taker["is_auto"]:
        select_index = random.randrange(len(passer["deck"]))
    else:
        while True:
            text = ''
            for n in range(len(passer["deck"])):
                text += f'[{n+1}] '
            select_index = input(
                f'\n\n\tSelect card of {passer["name"]} from {text}: ')
            try:
                select_index = int(select_index) - 1
                if select_index < 0 or select_index >= len(passer["deck"]):
                    raise IndexError()
            except ValueError:
                print('\t*please input intger!!!')
            except IndexError:
                print('\t*please input right number!!!')
            else:
                break
        print('\n\t', end='')
    selected_card = passer["deck"].pop(select_index)
    return selected_card


def putdown_or_add(selected_card: str, taker: dict) -> None:
    """
    Put down or add a card.
    *Return is not required for destructive methods.
    """
    try:
        taker["deck"].remove(selected_card)
    except ValueError:
        taker["deck"].append(selected_card)


def check_is_zero(player: dict, rank: list) -> None:
    """
    Check how many cards player have on hand.
    """
    if len(player["deck"]) == 0:
        player["card_exists"] = False
        rank.append(player["name"])


def run(players: list, rank: list) -> None:
    """
    Start the game.
    """
    passer_i = -1
    taker_i = 0
    loop = 0

    print('BABANUKI GAME START')

    while len(players) - len(rank) > 1:
        loop += 1
        print(f'\n[TURN {loop}]', end='')

        passer_i, taker_i = create_turn_index(passer_i, taker_i, players)

        print(
            f'\t{players[passer_i]["name"]} --> {players[taker_i]["name"]}', end='')

        text = '\t\t'
        for player in players:
            text += f'{player["name"]}:{len(player["deck"])} '
        print(text, end='')

        selected_card = select(players[passer_i], players[taker_i])
        check_is_zero(players[passer_i], rank)

        putdown_or_add(selected_card, players[taker_i])
        check_is_zero(players[taker_i], rank)

        text = '==> '
        for player in players:
            text += f'{player["name"]}:{len(player["deck"])} '
        print(text, end='')

        print(f'\tWINNERS: {",".join(rank)}', end='')

    player_name = [p["name"] for p in players if p["card_exists"]][0]
    rank.append(player_name)

    print('\n\nBABANUKI GAME END\n')
    for i, name in enumerate(rank):
        print(f'RANK {i+1}: {name}')

